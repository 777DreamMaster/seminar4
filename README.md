## React.memo()
Создаёт мемоизированную версию компонента. Она не будет ререндериться вместе с родительским компонентом если пропсы не поменялись. <br>
Получает в качестве аргументов компонент для мемоизации и функцию сравнения пропсов. Функция сравнения может быть не указана, в этом случае используется Object.is. <br>
Полезно для сохранения времени на рендере, но создание такого компонента требует лишней памяти, а при каждом ререндере будет проводиться дополнительная проверка наличия изменений в пропсах компонента. Мемоизацию не стоит использовать на небольших компонентах, ререндер которых требует мало времени.

## useMemo()
Возвращает мемоизированное значение. Содержимое хука будет выполняться только если изменятся зависимости. <br>
Получает в качестве аргументов функцию, значение которой мемоизируется, и список зависимостей. При пустом списке зависимостей значение никогда не будет пересчитываться, но это не является примером верного использования. <br>
Позволяет избежать повторных вычислений и тем самым экономит время, однако хранение мемоизироанного значения требует лишней памяти. Кроме того этот хук добавляет к каждому вызову функции проверку наличия изменений в зависимостях, что делает его использование неоправданным для легко пересчитываемых функций. <br>
Отличается от useCallback() тем, что возвращает меомоизированное значение функции, не пересчитывая его при множественных вызовах до тех пор пока зависимость не меняется.

## useCallback()
Возвращает меомизированную функцию. Хук возвращает не вычислинное значение функции, а саму функцию. <br>
Получает в качестве аргументов функцию для мемоизации и список зависиомстей. 
Позволяет избежать повторных созданий функции при ре-рендере компонентов, когда функции создаются заново. Как и все предыдущие примеры, добавляет к выполнению стоимость сравнения зависимостей при каждом вызове и требует дополнительной памяти. <br>
Отличается от useMemo() тем, что возвращает меомизированную функцию, соответственно при новом вызове useCallback() даже без изменений зависимостей будет заново пересчитывать функцию.
